---
title: "高级SQL"
subtitle: "Database system concepts, cn 6e, ch. 5"
layout: post
author: "Chris"
header-style: text
tags:
- 笔记
- 数据库
---

# 5.1 程序设计语言访问数据库

- 动态SQL

  > str式sql语句，返回关系存入变量（eg. JDBC, ODBC）

- 嵌入式SQL

  > 嵌入式sql语句必须在编译时全部确定，并交给预处理器
  >
  > 预处理器提交sql到dbms预编译、优化
  >
  > 把程序中sql语句替换成相应的代码和函数，再用程序语言的编译器编译

## 5.1.1 JDBC

```java
import java.sql.*;

private void demo() {
  try {
    Class.forName("org.postgresql.Driver");
    String url = "jdbc:postgresql://" + host + ":" + port + "/" + db;
    Connection conn = DriverManager.getConnection(url, user, pwd);
    
    Statement stmt = conn.createStatement();
    stmt.excuteUpdate("INSERT...");
    
    ResultSet rset = stmt.executeQuery("SELECT...");
    while(rset.next())
      System.out.println("...");
    
    stmt.close();
    conn.close();
  } catch (Exception e) {
    // ...
  }
}
```



# 5.2 SQL函数

> If a schema name is included, then the function is created in the specified schema. Otherwise it is created in the current schema.

> Functions and procedures of different argument types can share a name (this is called **overloading**).

> `CREATE OR REPLACE FUNCTION` will not let you change the return type of an existing function. To do that, you must drop and recreate the function. (When using `OUT` parameters, that means you cannot change the types of any `OUT` parameters except by dropping the function.)

> When `CREATE OR REPLACE FUNCTION` is used to replace an existing function, the ownership and permissions of the function do not change.

```sql
CREATE FUNCTION add_em(x integer, y integer)
    RETURNS integer AS
$$
SELECT x + y;
$$ LANGUAGE SQL;
```

```sql
CREATE FUNCTION double_salary(table_name)
    RETURNS numeric AS
$$
SELECT $1.col_name;
$$ LANGUAGE SQL;
```

```sql
-- SQL Functions with Output Parameters
CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT product int) AS
$$
SELECT x + y,
       x * y;
$$ LANGUAGE SQL;

-- can add default value  <x int DEFAULT 3>
```

## PSQL Functions

```plsql
CREATE OR REPLACE FUNCTION full_name(name1 varchar, name2 varchar)
    RETURNS varchar AS
$$
DECLARE
    name varchar := NULL;
BEGIN
    name := name1 || ' ' || name2;
    -- SELECT .. INTO name;
    RETURN name;
END;
$$ LANGUAGE plpgsql;
```

#### `IF` statements

```sql
IF UPPER(style) = 'W' THEN
    RETURN TRIM(COALESCE(p_fn, '') || ' ' || p_sn);
ELSEIF UPPER(style) = 'E' THEN
    RETURN TRIM(p_sn || ' ' || COALESCE(p_fn, ''));
ELSE
    RAISE EXCEPTION 'Style must be W or E';
END IF;
```

#### `FOR / WHILE` loops

```sql
FOR variable_value IN start_value..end_value LOOP
-- statements;
END LOOP;

WHILE condition LOOP
-- statements;
END LOOP;
```

`LEAVE` = break		`ITERATE` = continue		(unchecked in pSQL)

#### `RETURN QUERRY` returns a table

```sql
RETURNS TABLE
(
    col_name1 col_type,
    col_name2 col_type
)
-- ...
RETURN QUERY
	SELECT col1, col2 -- ...
```

> f(int), f(int, out int), f(int, int default ?) cannot be overloaded

> Difference between Function and **Procedure**
>
> - Stored procedures do not have to return anything, and only return a single row when using INOUT parameters.
>
> - You can commit and rollback transactions inside stored procedures, but not in functions.
>
> - You execute a stored procedure using the CALL statement rather than a SELECT statement.
>
> - Unlike functions, procedures cannot be nested in other DDL commands (SELECT, INSERT, UPDATE, DELETE).



# 5.3 触发器 Trigger

DBC 6e, pp.102

> `事件` 引起触发器被检测
>
> `条件` 使得触发器被执行
>
> `动作` 触发器的行为
>
> 先编写触发器函数，再将其显式附加到合适的触发器上

```plsql
CREATE [ CONSTRAINT ] TRIGGER name { BEFORE | AFTER | INSTEAD OF } { event [ OR ... ] }
																												-- event := INSERT, UPDATE [ OF column_name [, ...] ], DELETE, TRUNCATE
		ON table_name
		[ FROM referenced_table_name ]
		[ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ]
		[ REFERENCING { { OLD | NEW } TABLE [ AS ] transition_relation_name } [ ... ] ]
		[ FOR [ EACH ] { ROW | STATEMENT } ]
		[ WHEN ( condition ) ]
		EXECUTE { FUNCTION | PROCEDURE } function_name ( arguments )
```

### Classification

1. by location where triggers can be attached to
  - tables / views / foreign tables
2. by which trigger affected on
  - `per-row` : is invoked once for each row
  - `per-statement` : is invoked only once when an appropriate statement is executed

3. by whether they fire before, after, or instead of the operation
  - `before` :  *before*触发器的执行效率比*after*触发器高，在*before*触发器和*after*触发器都能被使用的情况下，应该选择*before*触发器。
  - `after`
  - `instead of` : may only be defined on views, and only at row level; they fire immediately as each row in the view is identified as needing to be operated on.

|    When    |        Event         |         Row-level         |          Statement-level          |
| :--------: | :------------------: | :-----------------------: | :-------------------------------: |
|   Before   | INSERT/UPDATE/DELETE | Tables and foreign tables | Tables, views, and foreign tables |
|   Before   |       TRUNCATE       |             -             |              Tables               |
|   AFTER    | INSERT/UPDATE/DELETE | Tables and foreign tables |              Tables               |
|   AFTER    |       TRUNCATE       |             -             |              Tables               |
| INSTEAD OF | INSERT/UPDATE/DELETE |           Views           |                 -                 |
| INSTEAD OF |       TRUNCATE       |             -             |                 -                 |

! The trigger function must be defined before the trigger itself can be created. The trigger function must be declared as a function taking no arguments and returning type `trigger` .

! The trigger function should be writen in **procedure language(PL) or C**, could not in pure SQL.

```sql
CREATE FUNCTION emp_stamp()
		RETURNS trigger AS
		$emp_stamp$
				BEGIN
				-- codes
				END;
		$emp_stamp$ LANGUAGE plpgsql;
		
CREATE TRIGGER trig_1
BEFORE INSERT OR UPDATE
	OF <col_1, ...>
	ON <table>
FOR EACH ROW
EXECUTE FUNCTION emp_stamp();
```

#### * Data passed in Trigger procedure

>   当一个*PL/pgSQL* 函数作为一个触发器被调用时，系统自动在最外层的块创建一些特殊的变量
>
> - `NEW`：数据类型是RECORD。对于行级触发器，它存有INSERT或UPDATE操作产生的新的数据行。对于语句级触发器，它的值是NULL。
>
> - `OLD`：数据类型是RECORD。对于行级触发器，它存有被UPDATE或DELETE操作修改或删除的旧的数据行。对于语句级触发器，它的值是NULL。
>
> - `TG_NAME`：数据类型是name，它保存实际被调用的触发器的名字。
>
> - `TG_WHEN`：数据类型是text，根据触发器定义信息的不同，它的值是BEFORE 或AFTER。
>
> - `TG_LEVEL`：数据类型是text，根据触发器定义信息的不同，它的值是ROW或STATEMENT。
>
> - `TG_OP`：数据类型是text，它的值是INSERT、UPDATE或DELETE，表示触发触发器的操作类型。
>
> - `TG_RELID`：数据类型是oid，表示触发器作用的表的oid。
>
> - `TG_RELNAME`：数据类型是name，表示触发器作用的表的名字。它与下面的变量TG_TABLE_NAME的作用是一样的。
>
> - `TG_TABLE_NAME`：数据类型是name，表示触发器作用的表的名字。
>
> - `TG_TABLE_SCHEMA`：数据类型是name，表示触发器作用的表所在的模式。
>
> - `TG_NARGS`：数据类型是integer，表示CREATE TRIGGER命令传给触发器过程的参数的个数。
>
> - `TG_ARGV[]`：数据类型是text类型的数组。表示CREATE TRIGGER命令传给触发器过程的所有参数。下标从0开始。TG_ARGV[0]表示第一个参数，TG_ARGV[1]表示第二个参数，以此类推。 如果下标小于0或大于等于tg_nargs，将会返回一个空值。



# 5.4 递归查询

**传递闭包 transitive closure**

